#!/bin/bash
# @file bb_get_fasta_headers 
# @brief Extracts headers from a single/multiple fasta file.
# @description 
#	Outputs a list of all fasta headers without the ">"in a fasta file.
#	It can be a single or multiple fasta file.
# @example 
#	bb_get_fasta_headers -i sequence.fasta 
# @arg $1 A valid fasta file.
# @exitcode 0 if succesful
# @exitcode 1 if unsuccesful
#
# Since sometimes remembering how exactly getopts work, this can be handy:
# https://www.tutorialspoint.com/unix_commands/getopt.htm
# getopt returns error code 0 for succesful parsing, 1 if getopt(3) returns errors, 
# 2 if it does not understand its own parameters, 3 if an internal error occurs like out-of-memory, 
# and 4 if it is called with -T.


# Source the whole BB native library.
source "$BIOBASH_NATIVE_LIB_PATH/bb_native.sh"

help="
	== BioBash get_fasta headers == 

	usage: bb_get_fasta_headers -i [fasta file]
	"



inData=$(io::input_is_pipe_or_file)
echo $inData


anyInput=$(io::input_is_empty)
if [[ $anyInput="empty" ]]; then
	echo $anyInput
	echo "$help"
	exit 1
fi

#--------------------------------------------------------------------------
#						Validate Input
#--------------------------------------------------------------------------
# Thanks to @barmar in Stackoverflow. 
# All explanation for this section can be found here:
# https://github.com/ampinzonv/biobash2/wiki/Blog::File-Descriptors
# https://github.com/ampinzonv/biobash2/wiki/Blog::BB-input-behavior

# When script is called without arguments, display help.




# Since by default BB will IGNORE any extra argument we only need to check two things.
# 1) That data comes via "-i" option using $OPTARG. 
# 2) That data comes from the terminal.
# Since the only way that BB script runs without a input file via "-i" option, is if
# data comes from terminal, we will check this first, because this overrides the use of "-i".
# The "-t 0" option here means that comes wether re-directed or as a pipe. For example:
#1)    [andres:~]$  ./myscript2.sh 
#       -t 0 == true
#2)    [andres:~]$  ./myscript2.sh myfile.txt 
#      -t 0 == true
#3)    [andres:~]$  cat myfile.txt | ./myscript2.sh 
#      -t 0 == false
#4)    [andres:~]$  ./myscript2.sh < myfile.txt
#      -t 0 == false
if [ -t 0 ]; then
	#If we are here it means that BB is expecting data from the terminal.
	# Meaning that nothing comes from the STDOUT via pipe o redirection.
	# So the only alternative is that input data comes as argument via "-i" option.
	while getopts i: option; 
	do
		case "${option}" in
			i)
				fastaFile="$OPTARG";;
					
			\?)
				feedback::sayfrom "Unknown parameter option." "error"
				echo "${help}"
				exit;;
		esac
	done

else
	# otherwise if we are here it means that BB is expecting data NOT FROM TERMINAL
	# but from STDOUT via a pipe or redirection.
	data=$(cat -- "$@")
	#Create a tmp file to hold data.
	fastaFile=$(file::make_temp_file)
		
	echo "$data" > $fastaFile
	#cat $fastaFile
fi


# To this point we have a file. Wether recently created from STDOUT or defined by the
# user with the "-i" option. We have to make sure file exists.
fileExists=$(file::file_exists $fastaFile)
if [[ $fileExists -eq 1 ]];then
	feedback::sayfrom "Unable to find file: ${fastaFile}." "error"
	echo "$help"
	exit 1
fi


# To this point we have a file. Now let's check that it is the kind we need.
# In this aprticular case we expect a fasta file.
isFasta=$(file::is_fasta $fastaFile) 
if [[ $isFasta == "0" ]];then

	#--- THIS IS THE CORE OF THE SCRIPT
	grep "^>" "$fastaFile"  | sed -e "s/>//"
	#---

else
	feedback::sayfrom "Provided $fastaFile file, is not a valid Fasta file." "error"
	exit 1
fi

exit 0	